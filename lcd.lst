   1               		.file	"lcd.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	lcd_write_command
  12               	lcd_write_command:
  13               	.LVL0:
  14               	.LFB10:
  15               		.file 1 "lcd.c"
   1:lcd.c         **** #include "lcd.h"
   2:lcd.c         **** 
   3:lcd.c         **** /*
   4:lcd.c         **** http://fizyka.if.pw.edu.pl/~labe/data/_uploaded/file/psm/Lab3.pdf
   5:lcd.c         **** http://fizyka.if.pw.edu.pl/~labe/data/_uploaded/file/psm/materialy/Noty_katalogowe/Obsluga%20LCD.pd
   6:lcd.c         **** */ 
   7:lcd.c         **** 
   8:lcd.c         **** static int lcd_print(char c, FILE *stream);
   9:lcd.c         **** 
  10:lcd.c         **** static FILE mystdout = FDEV_SETUP_STREAM(lcd_print, NULL, _FDEV_SETUP_WRITE);
  11:lcd.c         **** 
  12:lcd.c         **** static int lcd_print(char c, FILE *stream){
  13:lcd.c         ****     lcd_write_data(c);
  14:lcd.c         ****     return 0;
  15:lcd.c         **** }
  16:lcd.c         **** 
  17:lcd.c         **** void lcdinit(void){
  18:lcd.c         ****     LCD_PORT_DIR = 0xff;
  19:lcd.c         ****     LCD_PORT = 0x00;
  20:lcd.c         **** 
  21:lcd.c         ****     _delay_ms(50);
  22:lcd.c         **** 
  23:lcd.c         ****     stdout = &mystdout;
  24:lcd.c         **** 
  25:lcd.c         ****     LCD_PORT &= ~(1<<LCD_RS);
  26:lcd.c         **** 
  27:lcd.c         ****     for(uint8_t i=0; i<3; i++)
  28:lcd.c         ****     {
  29:lcd.c         ****         LCD_PORT |= (1<<LCD_E);
  30:lcd.c         ****         LCD_PORT = (LCD_PORT & 0x0f) | 0x30;
  31:lcd.c         ****         _delay_us(1);
  32:lcd.c         ****         LCD_PORT &= ~(1<<LCD_E);
  33:lcd.c         ****         _delay_ms(5);
  34:lcd.c         ****     }
  35:lcd.c         **** 
  36:lcd.c         ****     LCD_PORT |= (1<<LCD_E);
  37:lcd.c         ****     LCD_PORT = (LCD_PORT & 0x0f) | 0x20;
  38:lcd.c         ****     _delay_us(1);
  39:lcd.c         ****     LCD_PORT &= ~(1<<LCD_E);
  40:lcd.c         ****     _delay_us(100);
  41:lcd.c         **** 
  42:lcd.c         ****     //Konfiguracja wyświetlacza
  43:lcd.c         ****     lcd_write_command(0x28); //Interfejs 4bitowy, 2 linie, matryca 5x7
  44:lcd.c         ****     lcd_write_command(0x0c); //Włączenie LCD, wyłączenie kursora i miganie kursora
  45:lcd.c         ****     lcd_write_command(0x06); //Inkrementacja w prawo
  46:lcd.c         **** 
  47:lcd.c         ****     //zamiana 0b na 0x (binary to hex)
  48:lcd.c         ****     // 0010 1000 -> 0x28,
  49:lcd.c         ****     // 8421 8421
  50:lcd.c         **** 
  51:lcd.c         ****     // 0000 1100 -> 0x0c, bo 8+4 = 12 = 0x0c
  52:lcd.c         ****     // 8421 8421
  53:lcd.c         **** 
  54:lcd.c         ****     // 0000 0110 -> 0x06
  55:lcd.c         ****     // 8421 8421 
  56:lcd.c         ****     
  57:lcd.c         **** }
  58:lcd.c         **** 
  59:lcd.c         **** void lcd_write_command(uint8_t data){
  16               		.loc 1 59 37 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  60:lcd.c         ****     LCD_PORT &= ~(1<<LCD_RS);
  22               		.loc 1 60 5 view .LVU1
  23               		.loc 1 60 14 is_stmt 0 view .LVU2
  24 0000 DA98      		cbi 0x1b,2
  61:lcd.c         **** 
  62:lcd.c         ****     LCD_PORT |= (1<<LCD_E);
  25               		.loc 1 62 5 is_stmt 1 view .LVU3
  26               		.loc 1 62 14 is_stmt 0 view .LVU4
  27 0002 DB9A      		sbi 0x1b,3
  63:lcd.c         ****     LCD_PORT = (LCD_PORT & 0x0f) | (data & 0xf0);
  28               		.loc 1 63 5 is_stmt 1 view .LVU5
  29               		.loc 1 63 17 is_stmt 0 view .LVU6
  30 0004 9BB3      		in r25,0x1b
  31               		.loc 1 63 26 view .LVU7
  32 0006 9F70      		andi r25,lo8(15)
  33               		.loc 1 63 42 view .LVU8
  34 0008 282F      		mov r18,r24
  35 000a 207F      		andi r18,lo8(-16)
  36               		.loc 1 63 34 view .LVU9
  37 000c 922B      		or r25,r18
  38               		.loc 1 63 14 view .LVU10
  39 000e 9BBB      		out 0x1b,r25
  64:lcd.c         ****     _delay_us(1);
  40               		.loc 1 64 5 is_stmt 1 view .LVU11
  41               	.LVL1:
  42               	.LBB31:
  43               	.LBI31:
  44               		.file 2 "e:\\avr-gcc-10.1.0-x64-windows\\avr\\include\\util\\delay.h"
   1:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    All rights reserved.
   5:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
   6:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
   9:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  12:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****      distribution.
  16:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  17:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  21:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  33:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** /* $Id$ */
  34:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  35:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  38:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #  endif
  42:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  44:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #include <inttypes.h>
  45:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #include <math.h>
  47:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  48:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** /** \file */
  49:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     \code
  51:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     #include <util/delay.h>
  54:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     \endcode
  55:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  56:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     used.
  60:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  61:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  70:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     routines linked into the application.
  78:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  79:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  83:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** */
  84:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  85:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #endif
  89:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  90:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #ifndef F_CPU
  91:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** /** \ingroup util_delay
  94:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     \def F_CPU
  95:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  97:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 103:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****     integer value.
 107:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****  */
 108:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #endif
 110:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 111:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #endif
 114:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 115:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #  include <math.h>
 119:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #endif
 120:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 121:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** /**
 122:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    \ingroup util_delay
 123:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 124:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 126:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 129:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 131:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 137:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 142:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    microseconds of delay.
 146:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 147:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    respectively.
 151:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 152:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    \note
 153:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 154:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    not available to the compiler then.
 163:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 164:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****  */
 165:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** void
 166:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
 168:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	double __tmp ;
 169:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 176:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 179:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 182:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#else
 183:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		//round up by default
 184:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
 186:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 187:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 189:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #else
 190:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		__ticks = 1;
 194:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	{
 196:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		while(__ticks)
 199:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		{
 200:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 			__ticks --;
 203:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		}
 204:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		return;
 205:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	}
 206:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	else
 207:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #endif
 210:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** }
 211:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 212:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** /**
 213:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    \ingroup util_delay
 214:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 215:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 217:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 220:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 222:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    will not be informed about this case.
 225:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 226:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 231:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    microseconds of delay.
 235:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 236:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    respectively.
 240:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 241:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    \note
 242:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 243:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****    not available to the compiler then.
 252:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 253:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****  */
 254:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** void
 255:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** _delay_us(double __us)
  45               		.loc 2 255 1 view .LVU12
  46               	.LBB32:
 256:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
 257:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	double __tmp ;
  47               		.loc 2 257 2 view .LVU13
 258:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
  48               		.loc 2 261 2 view .LVU14
 262:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
  49               		.loc 2 262 2 view .LVU15
 263:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
  50               		.loc 2 263 2 view .LVU16
 264:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 265:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 268:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 271:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#else
 272:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		//round up by default
 273:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
  51               		.loc 2 273 3 view .LVU17
 274:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
 275:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 276:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  52               		.loc 2 276 2 view .LVU18
  53 0010 35E0      		ldi r19,lo8(5)
  54 0012 3A95      	1:	dec r19
  55 0014 01F4      		brne 1b
  56 0016 0000      		nop
  57               	.LVL2:
  58               		.loc 2 276 2 is_stmt 0 view .LVU19
  59               	.LBE32:
  60               	.LBE31:
  65:lcd.c         ****     LCD_PORT &= ~(1<<LCD_E);
  61               		.loc 1 65 5 is_stmt 1 view .LVU20
  62               		.loc 1 65 14 is_stmt 0 view .LVU21
  63 0018 DB98      		cbi 0x1b,3
  66:lcd.c         **** 
  67:lcd.c         ****     _delay_us(100);
  64               		.loc 1 67 5 is_stmt 1 view .LVU22
  65               	.LVL3:
  66               	.LBB33:
  67               	.LBI33:
 255:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
  68               		.loc 2 255 1 view .LVU23
  69               	.LBB34:
 257:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  70               		.loc 2 257 2 view .LVU24
 261:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
  71               		.loc 2 261 2 view .LVU25
 262:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
  72               		.loc 2 262 2 view .LVU26
 263:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
  73               		.loc 2 263 2 view .LVU27
 273:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
  74               		.loc 2 273 3 view .LVU28
  75               		.loc 2 276 2 view .LVU29
  76 001a EFE8      		ldi r30,lo8(399)
  77 001c F1E0      		ldi r31,hi8(399)
  78 001e 3197      	1:	sbiw r30,1
  79 0020 01F4      		brne 1b
  80 0022 00C0      		rjmp .
  81 0024 0000      		nop
  82               	.LVL4:
  83               		.loc 2 276 2 is_stmt 0 view .LVU30
  84               	.LBE34:
  85               	.LBE33:
  68:lcd.c         **** 
  69:lcd.c         ****     LCD_PORT |= (1<<LCD_E);
  86               		.loc 1 69 5 is_stmt 1 view .LVU31
  87               		.loc 1 69 14 is_stmt 0 view .LVU32
  88 0026 DB9A      		sbi 0x1b,3
  70:lcd.c         ****     LCD_PORT = (LCD_PORT & 0x0f) | (data & 0x0f)<<4;
  89               		.loc 1 70 5 is_stmt 1 view .LVU33
  90               		.loc 1 70 17 is_stmt 0 view .LVU34
  91 0028 2BB3      		in r18,0x1b
  92               		.loc 1 70 26 view .LVU35
  93 002a 2F70      		andi r18,lo8(15)
  94               		.loc 1 70 49 view .LVU36
  95 002c F0E1      		ldi r31,lo8(16)
  96 002e 8F9F      		mul r24,r31
  97 0030 C001      		movw r24,r0
  98 0032 1124      		clr __zero_reg__
  99               	.LVL5:
 100               		.loc 1 70 34 view .LVU37
 101 0034 822B      		or r24,r18
 102               		.loc 1 70 14 view .LVU38
 103 0036 8BBB      		out 0x1b,r24
  71:lcd.c         ****     _delay_us(1);
 104               		.loc 1 71 5 is_stmt 1 view .LVU39
 105               	.LVL6:
 106               	.LBB35:
 107               	.LBI35:
 255:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
 108               		.loc 2 255 1 view .LVU40
 109               	.LBB36:
 257:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 110               		.loc 2 257 2 view .LVU41
 261:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 111               		.loc 2 261 2 view .LVU42
 262:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 112               		.loc 2 262 2 view .LVU43
 263:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 113               		.loc 2 263 2 view .LVU44
 273:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
 114               		.loc 2 273 3 view .LVU45
 115               		.loc 2 276 2 view .LVU46
 116 0038 35E0      		ldi r19,lo8(5)
 117 003a 3A95      	1:	dec r19
 118 003c 01F4      		brne 1b
 119 003e 0000      		nop
 120               	.LVL7:
 121               		.loc 2 276 2 is_stmt 0 view .LVU47
 122               	.LBE36:
 123               	.LBE35:
  72:lcd.c         ****     LCD_PORT &= ~(1<<LCD_E);
 124               		.loc 1 72 5 is_stmt 1 view .LVU48
 125               		.loc 1 72 14 is_stmt 0 view .LVU49
 126 0040 DB98      		cbi 0x1b,3
  73:lcd.c         **** 
  74:lcd.c         ****     _delay_us(100);
 127               		.loc 1 74 5 is_stmt 1 view .LVU50
 128               	.LVL8:
 129               	.LBB37:
 130               	.LBI37:
 255:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
 131               		.loc 2 255 1 view .LVU51
 132               	.LBB38:
 257:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 133               		.loc 2 257 2 view .LVU52
 261:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 134               		.loc 2 261 2 view .LVU53
 262:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 135               		.loc 2 262 2 view .LVU54
 263:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 136               		.loc 2 263 2 view .LVU55
 273:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
 137               		.loc 2 273 3 view .LVU56
 138               		.loc 2 276 2 view .LVU57
 139 0042 8FE8      		ldi r24,lo8(399)
 140 0044 91E0      		ldi r25,hi8(399)
 141 0046 0197      	1:	sbiw r24,1
 142 0048 01F4      		brne 1b
 143 004a 00C0      		rjmp .
 144 004c 0000      		nop
 145               	.LVL9:
 146               	/* epilogue start */
 147               		.loc 2 276 2 is_stmt 0 view .LVU58
 148               	.LBE38:
 149               	.LBE37:
  75:lcd.c         **** }
 150               		.loc 1 75 1 view .LVU59
 151 004e 0895      		ret
 152               		.cfi_endproc
 153               	.LFE10:
 155               	.global	lcdinit
 157               	lcdinit:
 158               	.LFB9:
  17:lcd.c         ****     LCD_PORT_DIR = 0xff;
 159               		.loc 1 17 19 is_stmt 1 view -0
 160               		.cfi_startproc
 161               	/* prologue: function */
 162               	/* frame size = 0 */
 163               	/* stack size = 0 */
 164               	.L__stack_usage = 0
  18:lcd.c         ****     LCD_PORT = 0x00;
 165               		.loc 1 18 5 view .LVU61
  18:lcd.c         ****     LCD_PORT = 0x00;
 166               		.loc 1 18 18 is_stmt 0 view .LVU62
 167 0050 8FEF      		ldi r24,lo8(-1)
 168 0052 8ABB      		out 0x1a,r24
  19:lcd.c         **** 
 169               		.loc 1 19 5 is_stmt 1 view .LVU63
  19:lcd.c         **** 
 170               		.loc 1 19 14 is_stmt 0 view .LVU64
 171 0054 1BBA      		out 0x1b,__zero_reg__
  21:lcd.c         **** 
 172               		.loc 1 21 5 is_stmt 1 view .LVU65
 173               	.LVL10:
 174               	.LBB39:
 175               	.LBI39:
 166:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
 176               		.loc 2 166 1 view .LVU66
 177               	.LBB40:
 168:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 178               		.loc 2 168 2 view .LVU67
 172:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 179               		.loc 2 172 2 view .LVU68
 173:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 180               		.loc 2 173 2 view .LVU69
 174:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 181               		.loc 2 174 2 view .LVU70
 184:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
 182               		.loc 2 184 3 view .LVU71
 187:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 183               		.loc 2 187 2 view .LVU72
 184 0056 2FEF      		ldi r18,lo8(159999)
 185 0058 80E7      		ldi r24,hi8(159999)
 186 005a 92E0      		ldi r25,hlo8(159999)
 187 005c 2150      	1:	subi r18,1
 188 005e 8040      		sbci r24,0
 189 0060 9040      		sbci r25,0
 190 0062 01F4      		brne 1b
 191 0064 00C0      		rjmp .
 192 0066 0000      		nop
 193               	.LVL11:
 187:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 194               		.loc 2 187 2 is_stmt 0 view .LVU73
 195               	.LBE40:
 196               	.LBE39:
  23:lcd.c         **** 
 197               		.loc 1 23 5 is_stmt 1 view .LVU74
  23:lcd.c         **** 
 198               		.loc 1 23 12 is_stmt 0 view .LVU75
 199 0068 80E0      		ldi r24,lo8(mystdout)
 200 006a 90E0      		ldi r25,hi8(mystdout)
 201 006c 9093 0000 		sts __iob+2+1,r25
 202 0070 8093 0000 		sts __iob+2,r24
  25:lcd.c         **** 
 203               		.loc 1 25 5 is_stmt 1 view .LVU76
  25:lcd.c         **** 
 204               		.loc 1 25 14 is_stmt 0 view .LVU77
 205 0074 DA98      		cbi 0x1b,2
  27:lcd.c         ****     {
 206               		.loc 1 27 5 is_stmt 1 view .LVU78
 207               	.LBB41:
  27:lcd.c         ****     {
 208               		.loc 1 27 9 view .LVU79
 209               	.LVL12:
  27:lcd.c         ****     {
 210               		.loc 1 27 22 view .LVU80
 211               	.LBE41:
  25:lcd.c         **** 
 212               		.loc 1 25 14 is_stmt 0 view .LVU81
 213 0076 93E0      		ldi r25,lo8(3)
 214               	.LVL13:
 215               	.L3:
 216               	.LBB46:
  29:lcd.c         ****         LCD_PORT = (LCD_PORT & 0x0f) | 0x30;
 217               		.loc 1 29 9 is_stmt 1 discriminator 3 view .LVU82
  29:lcd.c         ****         LCD_PORT = (LCD_PORT & 0x0f) | 0x30;
 218               		.loc 1 29 18 is_stmt 0 discriminator 3 view .LVU83
 219 0078 DB9A      		sbi 0x1b,3
  30:lcd.c         ****         _delay_us(1);
 220               		.loc 1 30 9 is_stmt 1 discriminator 3 view .LVU84
  30:lcd.c         ****         _delay_us(1);
 221               		.loc 1 30 21 is_stmt 0 discriminator 3 view .LVU85
 222 007a 8BB3      		in r24,0x1b
  30:lcd.c         ****         _delay_us(1);
 223               		.loc 1 30 30 discriminator 3 view .LVU86
 224 007c 8F70      		andi r24,lo8(15)
  30:lcd.c         ****         _delay_us(1);
 225               		.loc 1 30 38 discriminator 3 view .LVU87
 226 007e 8063      		ori r24,lo8(48)
  30:lcd.c         ****         _delay_us(1);
 227               		.loc 1 30 18 discriminator 3 view .LVU88
 228 0080 8BBB      		out 0x1b,r24
  31:lcd.c         ****         LCD_PORT &= ~(1<<LCD_E);
 229               		.loc 1 31 9 is_stmt 1 discriminator 3 view .LVU89
 230               	.LVL14:
 231               	.LBB42:
 232               	.LBI42:
 255:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
 233               		.loc 2 255 1 discriminator 3 view .LVU90
 234               	.LBB43:
 257:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 235               		.loc 2 257 2 discriminator 3 view .LVU91
 261:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 236               		.loc 2 261 2 discriminator 3 view .LVU92
 262:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 237               		.loc 2 262 2 discriminator 3 view .LVU93
 263:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 238               		.loc 2 263 2 discriminator 3 view .LVU94
 273:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
 239               		.loc 2 273 3 discriminator 3 view .LVU95
 240               		.loc 2 276 2 discriminator 3 view .LVU96
 241 0082 E5E0      		ldi r30,lo8(5)
 242 0084 EA95      	1:	dec r30
 243 0086 01F4      		brne 1b
 244 0088 0000      		nop
 245               	.LVL15:
 246               		.loc 2 276 2 is_stmt 0 discriminator 3 view .LVU97
 247               	.LBE43:
 248               	.LBE42:
  32:lcd.c         ****         _delay_ms(5);
 249               		.loc 1 32 9 is_stmt 1 discriminator 3 view .LVU98
  32:lcd.c         ****         _delay_ms(5);
 250               		.loc 1 32 18 is_stmt 0 discriminator 3 view .LVU99
 251 008a DB98      		cbi 0x1b,3
  33:lcd.c         ****     }
 252               		.loc 1 33 9 is_stmt 1 discriminator 3 view .LVU100
 253               	.LVL16:
 254               	.LBB44:
 255               	.LBI44:
 166:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
 256               		.loc 2 166 1 discriminator 3 view .LVU101
 257               	.LBB45:
 168:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 258               		.loc 2 168 2 discriminator 3 view .LVU102
 172:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 259               		.loc 2 172 2 discriminator 3 view .LVU103
 173:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 260               		.loc 2 173 2 discriminator 3 view .LVU104
 174:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 261               		.loc 2 174 2 discriminator 3 view .LVU105
 184:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
 262               		.loc 2 184 3 discriminator 3 view .LVU106
 187:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 263               		.loc 2 187 2 discriminator 3 view .LVU107
 264 008c EFE1      		ldi r30,lo8(19999)
 265 008e FEE4      		ldi r31,hi8(19999)
 266 0090 3197      	1:	sbiw r30,1
 267 0092 01F4      		brne 1b
 268 0094 00C0      		rjmp .
 269 0096 0000      		nop
 270               	.LVL17:
 187:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 271               		.loc 2 187 2 is_stmt 0 discriminator 3 view .LVU108
 272               	.LBE45:
 273               	.LBE44:
  27:lcd.c         ****     {
 274               		.loc 1 27 27 is_stmt 1 discriminator 3 view .LVU109
  27:lcd.c         ****     {
 275               		.loc 1 27 22 discriminator 3 view .LVU110
  27:lcd.c         ****     {
 276               		.loc 1 27 5 is_stmt 0 discriminator 3 view .LVU111
 277 0098 9150      		subi r25,lo8(-(-1))
 278               	.LVL18:
  27:lcd.c         ****     {
 279               		.loc 1 27 5 discriminator 3 view .LVU112
 280 009a 01F4      		brne .L3
 281               	.LBE46:
  36:lcd.c         ****     LCD_PORT = (LCD_PORT & 0x0f) | 0x20;
 282               		.loc 1 36 5 is_stmt 1 view .LVU113
  36:lcd.c         ****     LCD_PORT = (LCD_PORT & 0x0f) | 0x20;
 283               		.loc 1 36 14 is_stmt 0 view .LVU114
 284 009c DB9A      		sbi 0x1b,3
  37:lcd.c         ****     _delay_us(1);
 285               		.loc 1 37 5 is_stmt 1 view .LVU115
  37:lcd.c         ****     _delay_us(1);
 286               		.loc 1 37 17 is_stmt 0 view .LVU116
 287 009e 8BB3      		in r24,0x1b
  37:lcd.c         ****     _delay_us(1);
 288               		.loc 1 37 26 view .LVU117
 289 00a0 8F70      		andi r24,lo8(15)
  37:lcd.c         ****     _delay_us(1);
 290               		.loc 1 37 34 view .LVU118
 291 00a2 8062      		ori r24,lo8(32)
  37:lcd.c         ****     _delay_us(1);
 292               		.loc 1 37 14 view .LVU119
 293 00a4 8BBB      		out 0x1b,r24
  38:lcd.c         ****     LCD_PORT &= ~(1<<LCD_E);
 294               		.loc 1 38 5 is_stmt 1 view .LVU120
 295               	.LVL19:
 296               	.LBB47:
 297               	.LBI47:
 255:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
 298               		.loc 2 255 1 view .LVU121
 299               	.LBB48:
 257:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 300               		.loc 2 257 2 view .LVU122
 261:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 301               		.loc 2 261 2 view .LVU123
 262:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 302               		.loc 2 262 2 view .LVU124
 263:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 303               		.loc 2 263 2 view .LVU125
 273:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
 304               		.loc 2 273 3 view .LVU126
 305               		.loc 2 276 2 view .LVU127
 306 00a6 F5E0      		ldi r31,lo8(5)
 307 00a8 FA95      	1:	dec r31
 308 00aa 01F4      		brne 1b
 309 00ac 0000      		nop
 310               	.LVL20:
 311               		.loc 2 276 2 is_stmt 0 view .LVU128
 312               	.LBE48:
 313               	.LBE47:
  39:lcd.c         ****     _delay_us(100);
 314               		.loc 1 39 5 is_stmt 1 view .LVU129
  39:lcd.c         ****     _delay_us(100);
 315               		.loc 1 39 14 is_stmt 0 view .LVU130
 316 00ae DB98      		cbi 0x1b,3
  40:lcd.c         **** 
 317               		.loc 1 40 5 is_stmt 1 view .LVU131
 318               	.LVL21:
 319               	.LBB49:
 320               	.LBI49:
 255:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
 321               		.loc 2 255 1 view .LVU132
 322               	.LBB50:
 257:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 323               		.loc 2 257 2 view .LVU133
 261:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 324               		.loc 2 261 2 view .LVU134
 262:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 325               		.loc 2 262 2 view .LVU135
 263:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 326               		.loc 2 263 2 view .LVU136
 273:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
 327               		.loc 2 273 3 view .LVU137
 328               		.loc 2 276 2 view .LVU138
 329 00b0 8FE8      		ldi r24,lo8(399)
 330 00b2 91E0      		ldi r25,hi8(399)
 331 00b4 0197      	1:	sbiw r24,1
 332 00b6 01F4      		brne 1b
 333 00b8 00C0      		rjmp .
 334 00ba 0000      		nop
 335               	.LVL22:
 336               		.loc 2 276 2 is_stmt 0 view .LVU139
 337               	.LBE50:
 338               	.LBE49:
  43:lcd.c         ****     lcd_write_command(0x0c); //Włączenie LCD, wyłączenie kursora i miganie kursora
 339               		.loc 1 43 5 is_stmt 1 view .LVU140
 340 00bc 88E2      		ldi r24,lo8(40)
 341 00be 0E94 0000 		call lcd_write_command
 342               	.LVL23:
  44:lcd.c         ****     lcd_write_command(0x06); //Inkrementacja w prawo
 343               		.loc 1 44 5 view .LVU141
 344 00c2 8CE0      		ldi r24,lo8(12)
 345 00c4 0E94 0000 		call lcd_write_command
 346               	.LVL24:
  45:lcd.c         **** 
 347               		.loc 1 45 5 view .LVU142
 348 00c8 86E0      		ldi r24,lo8(6)
 349 00ca 0C94 0000 		jmp lcd_write_command
 350               	.LVL25:
 351               		.cfi_endproc
 352               	.LFE9:
 354               	.global	lcd_clear
 356               	lcd_clear:
 357               	.LFB11:
  76:lcd.c         **** 
  77:lcd.c         **** void lcd_clear(void){
 358               		.loc 1 77 21 view -0
 359               		.cfi_startproc
 360               	/* prologue: function */
 361               	/* frame size = 0 */
 362               	/* stack size = 0 */
 363               	.L__stack_usage = 0
  78:lcd.c         ****     lcd_write_command(1);
 364               		.loc 1 78 5 view .LVU144
 365 00ce 81E0      		ldi r24,lo8(1)
 366 00d0 0E94 0000 		call lcd_write_command
 367               	.LVL26:
  79:lcd.c         ****     _delay_ms(2);
 368               		.loc 1 79 5 view .LVU145
 369               	.LBB51:
 370               	.LBI51:
 166:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
 371               		.loc 2 166 1 view .LVU146
 372               	.LBB52:
 168:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 373               		.loc 2 168 2 view .LVU147
 172:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 374               		.loc 2 172 2 view .LVU148
 173:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 375               		.loc 2 173 2 view .LVU149
 174:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 376               		.loc 2 174 2 view .LVU150
 184:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
 377               		.loc 2 184 3 view .LVU151
 187:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 378               		.loc 2 187 2 view .LVU152
 379 00d4 8FE3      		ldi r24,lo8(7999)
 380 00d6 9FE1      		ldi r25,hi8(7999)
 381 00d8 0197      	1:	sbiw r24,1
 382 00da 01F4      		brne 1b
 383 00dc 00C0      		rjmp .
 384 00de 0000      		nop
 385               	.LVL27:
 386               	/* epilogue start */
 187:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 387               		.loc 2 187 2 is_stmt 0 view .LVU153
 388               	.LBE52:
 389               	.LBE51:
  80:lcd.c         **** }
 390               		.loc 1 80 1 view .LVU154
 391 00e0 0895      		ret
 392               		.cfi_endproc
 393               	.LFE11:
 395               	.global	lcd_write_data
 397               	lcd_write_data:
 398               	.LVL28:
 399               	.LFB12:
  81:lcd.c         **** 
  82:lcd.c         **** void lcd_write_data(uint8_t data){
 400               		.loc 1 82 34 is_stmt 1 view -0
 401               		.cfi_startproc
 402               	/* prologue: function */
 403               	/* frame size = 0 */
 404               	/* stack size = 0 */
 405               	.L__stack_usage = 0
  83:lcd.c         ****     LCD_PORT |= (1<<LCD_RS);
 406               		.loc 1 83 5 view .LVU156
 407               		.loc 1 83 14 is_stmt 0 view .LVU157
 408 00e2 DA9A      		sbi 0x1b,2
  84:lcd.c         **** 
  85:lcd.c         ****     LCD_PORT |= (1<<LCD_E);
 409               		.loc 1 85 5 is_stmt 1 view .LVU158
 410               		.loc 1 85 14 is_stmt 0 view .LVU159
 411 00e4 DB9A      		sbi 0x1b,3
  86:lcd.c         ****     LCD_PORT = (LCD_PORT & 0x0f) | (data & 0xf0);
 412               		.loc 1 86 5 is_stmt 1 view .LVU160
 413               		.loc 1 86 17 is_stmt 0 view .LVU161
 414 00e6 9BB3      		in r25,0x1b
 415               		.loc 1 86 26 view .LVU162
 416 00e8 9F70      		andi r25,lo8(15)
 417               		.loc 1 86 42 view .LVU163
 418 00ea 282F      		mov r18,r24
 419 00ec 207F      		andi r18,lo8(-16)
 420               		.loc 1 86 34 view .LVU164
 421 00ee 922B      		or r25,r18
 422               		.loc 1 86 14 view .LVU165
 423 00f0 9BBB      		out 0x1b,r25
  87:lcd.c         ****     _delay_us(1);
 424               		.loc 1 87 5 is_stmt 1 view .LVU166
 425               	.LVL29:
 426               	.LBB53:
 427               	.LBI53:
 255:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
 428               		.loc 2 255 1 view .LVU167
 429               	.LBB54:
 257:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 430               		.loc 2 257 2 view .LVU168
 261:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 431               		.loc 2 261 2 view .LVU169
 262:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 432               		.loc 2 262 2 view .LVU170
 263:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 433               		.loc 2 263 2 view .LVU171
 273:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
 434               		.loc 2 273 3 view .LVU172
 435               		.loc 2 276 2 view .LVU173
 436 00f2 35E0      		ldi r19,lo8(5)
 437 00f4 3A95      	1:	dec r19
 438 00f6 01F4      		brne 1b
 439 00f8 0000      		nop
 440               	.LVL30:
 441               		.loc 2 276 2 is_stmt 0 view .LVU174
 442               	.LBE54:
 443               	.LBE53:
  88:lcd.c         ****     LCD_PORT &= ~(1<<LCD_E);
 444               		.loc 1 88 5 is_stmt 1 view .LVU175
 445               		.loc 1 88 14 is_stmt 0 view .LVU176
 446 00fa DB98      		cbi 0x1b,3
  89:lcd.c         **** 
  90:lcd.c         ****     _delay_us(100);
 447               		.loc 1 90 5 is_stmt 1 view .LVU177
 448               	.LVL31:
 449               	.LBB55:
 450               	.LBI55:
 255:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
 451               		.loc 2 255 1 view .LVU178
 452               	.LBB56:
 257:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 453               		.loc 2 257 2 view .LVU179
 261:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 454               		.loc 2 261 2 view .LVU180
 262:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 455               		.loc 2 262 2 view .LVU181
 263:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 456               		.loc 2 263 2 view .LVU182
 273:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
 457               		.loc 2 273 3 view .LVU183
 458               		.loc 2 276 2 view .LVU184
 459 00fc EFE8      		ldi r30,lo8(399)
 460 00fe F1E0      		ldi r31,hi8(399)
 461 0100 3197      	1:	sbiw r30,1
 462 0102 01F4      		brne 1b
 463 0104 00C0      		rjmp .
 464 0106 0000      		nop
 465               	.LVL32:
 466               		.loc 2 276 2 is_stmt 0 view .LVU185
 467               	.LBE56:
 468               	.LBE55:
  91:lcd.c         **** 
  92:lcd.c         ****     LCD_PORT |= (1<<LCD_E);
 469               		.loc 1 92 5 is_stmt 1 view .LVU186
 470               		.loc 1 92 14 is_stmt 0 view .LVU187
 471 0108 DB9A      		sbi 0x1b,3
  93:lcd.c         ****     LCD_PORT = (LCD_PORT & 0x0f) | (data & 0x0f)<<4;
 472               		.loc 1 93 5 is_stmt 1 view .LVU188
 473               		.loc 1 93 17 is_stmt 0 view .LVU189
 474 010a 2BB3      		in r18,0x1b
 475               		.loc 1 93 26 view .LVU190
 476 010c 2F70      		andi r18,lo8(15)
 477               		.loc 1 93 49 view .LVU191
 478 010e F0E1      		ldi r31,lo8(16)
 479 0110 8F9F      		mul r24,r31
 480 0112 C001      		movw r24,r0
 481 0114 1124      		clr __zero_reg__
 482               	.LVL33:
 483               		.loc 1 93 34 view .LVU192
 484 0116 822B      		or r24,r18
 485               		.loc 1 93 14 view .LVU193
 486 0118 8BBB      		out 0x1b,r24
  94:lcd.c         ****     _delay_us(1);
 487               		.loc 1 94 5 is_stmt 1 view .LVU194
 488               	.LVL34:
 489               	.LBB57:
 490               	.LBI57:
 255:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
 491               		.loc 2 255 1 view .LVU195
 492               	.LBB58:
 257:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 493               		.loc 2 257 2 view .LVU196
 261:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 494               		.loc 2 261 2 view .LVU197
 262:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 495               		.loc 2 262 2 view .LVU198
 263:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 496               		.loc 2 263 2 view .LVU199
 273:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
 497               		.loc 2 273 3 view .LVU200
 498               		.loc 2 276 2 view .LVU201
 499 011a 35E0      		ldi r19,lo8(5)
 500 011c 3A95      	1:	dec r19
 501 011e 01F4      		brne 1b
 502 0120 0000      		nop
 503               	.LVL35:
 504               		.loc 2 276 2 is_stmt 0 view .LVU202
 505               	.LBE58:
 506               	.LBE57:
  95:lcd.c         ****     LCD_PORT &= ~(1<<LCD_E);
 507               		.loc 1 95 5 is_stmt 1 view .LVU203
 508               		.loc 1 95 14 is_stmt 0 view .LVU204
 509 0122 DB98      		cbi 0x1b,3
  96:lcd.c         **** 
  97:lcd.c         ****     _delay_us(100);
 510               		.loc 1 97 5 is_stmt 1 view .LVU205
 511               	.LVL36:
 512               	.LBB59:
 513               	.LBI59:
 255:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** {
 514               		.loc 2 255 1 view .LVU206
 515               	.LBB60:
 257:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 516               		.loc 2 257 2 view .LVU207
 261:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 517               		.loc 2 261 2 view .LVU208
 262:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 518               		.loc 2 262 2 view .LVU209
 263:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 
 519               		.loc 2 263 2 view .LVU210
 273:e:\avr-gcc-10.1.0-x64-windows\avr\include\util\delay.h **** 	#endif
 520               		.loc 2 273 3 view .LVU211
 521               		.loc 2 276 2 view .LVU212
 522 0124 8FE8      		ldi r24,lo8(399)
 523 0126 91E0      		ldi r25,hi8(399)
 524 0128 0197      	1:	sbiw r24,1
 525 012a 01F4      		brne 1b
 526 012c 00C0      		rjmp .
 527 012e 0000      		nop
 528               	.LVL37:
 529               	/* epilogue start */
 530               		.loc 2 276 2 is_stmt 0 view .LVU213
 531               	.LBE60:
 532               	.LBE59:
  98:lcd.c         **** }
 533               		.loc 1 98 1 view .LVU214
 534 0130 0895      		ret
 535               		.cfi_endproc
 536               	.LFE12:
 539               	lcd_print:
 540               	.LVL38:
 541               	.LFB8:
  12:lcd.c         ****     lcd_write_data(c);
 542               		.loc 1 12 43 is_stmt 1 view -0
 543               		.cfi_startproc
 544               	/* prologue: function */
 545               	/* frame size = 0 */
 546               	/* stack size = 0 */
 547               	.L__stack_usage = 0
  13:lcd.c         ****     return 0;
 548               		.loc 1 13 5 view .LVU216
 549 0132 0E94 0000 		call lcd_write_data
 550               	.LVL39:
  14:lcd.c         **** }
 551               		.loc 1 14 5 view .LVU217
  15:lcd.c         **** 
 552               		.loc 1 15 1 is_stmt 0 view .LVU218
 553 0136 90E0      		ldi r25,0
 554 0138 80E0      		ldi r24,0
 555               	/* epilogue start */
 556 013a 0895      		ret
 557               		.cfi_endproc
 558               	.LFE8:
 560               	.global	lcd_set_xy
 562               	lcd_set_xy:
 563               	.LVL40:
 564               	.LFB13:
  99:lcd.c         **** 
 100:lcd.c         **** void lcd_set_xy(uint8_t r, uint8_t k){
 565               		.loc 1 100 38 is_stmt 1 view -0
 566               		.cfi_startproc
 567               	/* prologue: function */
 568               	/* frame size = 0 */
 569               	/* stack size = 0 */
 570               	.L__stack_usage = 0
 101:lcd.c         ****     lcd_write_command(0x80 | (0x40*r+k)); //r=0 -> pierwszy rzad, r=1 -> drugi rzad, k = kolumna
 571               		.loc 1 101 5 view .LVU220
 572               		.loc 1 101 37 is_stmt 0 view .LVU221
 573 013c 8295      		swap r24
 574               	.LVL41:
 575               		.loc 1 101 37 view .LVU222
 576 013e 880F      		lsl r24
 577 0140 880F      		lsl r24
 578 0142 807C      		andi r24,lo8(-64)
 579 0144 860F      		add r24,r22
 580               		.loc 1 101 5 view .LVU223
 581 0146 8068      		ori r24,lo8(-128)
 582 0148 0C94 0000 		jmp lcd_write_command
 583               	.LVL42:
 584               		.loc 1 101 5 view .LVU224
 585               		.cfi_endproc
 586               	.LFE13:
 588               	.global	lcd_write_text_xy
 590               	lcd_write_text_xy:
 591               	.LVL43:
 592               	.LFB14:
 102:lcd.c         **** }
 103:lcd.c         **** 
 104:lcd.c         **** void lcd_write_text_xy(uint8_t r, uint8_t k, char *text){
 593               		.loc 1 104 57 is_stmt 1 view -0
 594               		.cfi_startproc
 595               		.loc 1 104 57 is_stmt 0 view .LVU226
 596 014c 0F93      		push r16
 597               	.LCFI0:
 598               		.cfi_def_cfa_offset 3
 599               		.cfi_offset 16, -2
 600 014e 1F93      		push r17
 601               	.LCFI1:
 602               		.cfi_def_cfa_offset 4
 603               		.cfi_offset 17, -3
 604 0150 CF93      		push r28
 605               	.LCFI2:
 606               		.cfi_def_cfa_offset 5
 607               		.cfi_offset 28, -4
 608 0152 DF93      		push r29
 609               	.LCFI3:
 610               		.cfi_def_cfa_offset 6
 611               		.cfi_offset 29, -5
 612               	/* prologue: function */
 613               	/* frame size = 0 */
 614               	/* stack size = 4 */
 615               	.L__stack_usage = 4
 616 0154 8A01      		movw r16,r20
 105:lcd.c         ****     lcd_set_xy(r,k);
 617               		.loc 1 105 5 is_stmt 1 view .LVU227
 618 0156 0E94 0000 		call lcd_set_xy
 619               	.LVL44:
 106:lcd.c         **** 
 107:lcd.c         ****     while(*text!=0){
 620               		.loc 1 107 5 view .LVU228
 621 015a E801      		movw r28,r16
 622               	.LVL45:
 623               	.L10:
 624               		.loc 1 107 10 view .LVU229
 625               		.loc 1 107 11 is_stmt 0 view .LVU230
 626 015c 8991      		ld r24,Y+
 627               	.LVL46:
 628               		.loc 1 107 10 view .LVU231
 629 015e 8111      		cpse r24,__zero_reg__
 630 0160 00C0      		rjmp .L11
 631               	/* epilogue start */
 108:lcd.c         ****         lcd_write_data((uint8_t)*text);
 109:lcd.c         ****         text++;
 110:lcd.c         ****     }
 111:lcd.c         **** }
 632               		.loc 1 111 1 view .LVU232
 633 0162 DF91      		pop r29
 634 0164 CF91      		pop r28
 635               	.LVL47:
 636               		.loc 1 111 1 view .LVU233
 637 0166 1F91      		pop r17
 638 0168 0F91      		pop r16
 639 016a 0895      		ret
 640               	.LVL48:
 641               	.L11:
 108:lcd.c         ****         lcd_write_data((uint8_t)*text);
 642               		.loc 1 108 9 is_stmt 1 view .LVU234
 643 016c 0E94 0000 		call lcd_write_data
 644               	.LVL49:
 109:lcd.c         ****     }
 645               		.loc 1 109 9 view .LVU235
 109:lcd.c         ****     }
 646               		.loc 1 109 9 is_stmt 0 view .LVU236
 647 0170 00C0      		rjmp .L10
 648               		.cfi_endproc
 649               	.LFE14:
 651               	.global	lcd_write_text_P
 653               	lcd_write_text_P:
 654               	.LVL50:
 655               	.LFB15:
 112:lcd.c         **** 
 113:lcd.c         **** void lcd_write_text_P(const char *text){
 656               		.loc 1 113 40 is_stmt 1 view -0
 657               		.cfi_startproc
 658               		.loc 1 113 40 is_stmt 0 view .LVU238
 659 0172 CF93      		push r28
 660               	.LCFI4:
 661               		.cfi_def_cfa_offset 3
 662               		.cfi_offset 28, -2
 663 0174 DF93      		push r29
 664               	.LCFI5:
 665               		.cfi_def_cfa_offset 4
 666               		.cfi_offset 29, -3
 667               	/* prologue: function */
 668               	/* frame size = 0 */
 669               	/* stack size = 2 */
 670               	.L__stack_usage = 2
 671 0176 EC01      		movw r28,r24
 114:lcd.c         ****     register uint8_t ch;
 672               		.loc 1 114 5 is_stmt 1 view .LVU239
 115:lcd.c         **** 
 116:lcd.c         ****     while( (ch=pgm_read_byte(text++)) ){
 673               		.loc 1 116 5 view .LVU240
 674               	.LVL51:
 675               	.L13:
 676               		.loc 1 116 10 view .LVU241
 677               	.LBB61:
 678               		.loc 1 116 16 view .LVU242
 679               		.loc 1 116 16 view .LVU243
 680               		.loc 1 116 16 view .LVU244
 681 0178 FE01      		movw r30,r28
 682               	/* #APP */
 683               	 ;  116 "lcd.c" 1
 684 017a 8491      		lpm r24, Z
 685               		
 686               	 ;  0 "" 2
 687               	.LVL52:
 688               		.loc 1 116 16 view .LVU245
 689               		.loc 1 116 16 is_stmt 0 view .LVU246
 690               	/* #NOAPP */
 691               	.LBE61:
 692               		.loc 1 116 10 view .LVU247
 693 017c 2196      		adiw r28,1
 694               	.LVL53:
 695               		.loc 1 116 10 view .LVU248
 696 017e 8111      		cpse r24,__zero_reg__
 697 0180 00C0      		rjmp .L14
 698               	/* epilogue start */
 117:lcd.c         ****         lcd_write_data(ch);
 118:lcd.c         ****     }
 119:lcd.c         **** }...
 699               		.loc 1 119 1 view .LVU249
 700 0182 DF91      		pop r29
 701 0184 CF91      		pop r28
 702               	.LVL54:
 703               		.loc 1 119 1 view .LVU250
 704 0186 0895      		ret
 705               	.LVL55:
 706               	.L14:
 117:lcd.c         ****         lcd_write_data(ch);
 707               		.loc 1 117 9 is_stmt 1 view .LVU251
 708 0188 0E94 0000 		call lcd_write_data
 709               	.LVL56:
 117:lcd.c         ****         lcd_write_data(ch);
 710               		.loc 1 117 9 is_stmt 0 view .LVU252
 711 018c 00C0      		rjmp .L13
 712               		.cfi_endproc
 713               	.LFE15:
 715               		.data
 718               	mystdout:
 719 0000 0000 00   		.zero	3
 720 0003 02        		.byte	2
 721 0004 0000 0000 		.zero	4
 722 0008 0000      		.word	gs(lcd_print)
 723 000a 0000      		.word	0
 724 000c 0000      		.word	0
 725               		.text
 726               	.Letext0:
 727               		.file 3 "e:\\avr-gcc-10.1.0-x64-windows\\avr\\include\\stdint.h"
 728               		.file 4 "e:\\avr-gcc-10.1.0-x64-windows\\avr\\include\\stdio.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 lcd.c
C:\Users\KRZYSZ~1\AppData\Local\Temp\ccOzFbLV.s:2      *ABS*:000000000000003e __SP_H__
C:\Users\KRZYSZ~1\AppData\Local\Temp\ccOzFbLV.s:3      *ABS*:000000000000003d __SP_L__
C:\Users\KRZYSZ~1\AppData\Local\Temp\ccOzFbLV.s:4      *ABS*:000000000000003f __SREG__
C:\Users\KRZYSZ~1\AppData\Local\Temp\ccOzFbLV.s:5      *ABS*:0000000000000000 __tmp_reg__
C:\Users\KRZYSZ~1\AppData\Local\Temp\ccOzFbLV.s:6      *ABS*:0000000000000001 __zero_reg__
C:\Users\KRZYSZ~1\AppData\Local\Temp\ccOzFbLV.s:12     .text:0000000000000000 lcd_write_command
C:\Users\KRZYSZ~1\AppData\Local\Temp\ccOzFbLV.s:157    .text:0000000000000050 lcdinit
C:\Users\KRZYSZ~1\AppData\Local\Temp\ccOzFbLV.s:718    .data:0000000000000000 mystdout
C:\Users\KRZYSZ~1\AppData\Local\Temp\ccOzFbLV.s:356    .text:00000000000000ce lcd_clear
C:\Users\KRZYSZ~1\AppData\Local\Temp\ccOzFbLV.s:397    .text:00000000000000e2 lcd_write_data
C:\Users\KRZYSZ~1\AppData\Local\Temp\ccOzFbLV.s:539    .text:0000000000000132 lcd_print
C:\Users\KRZYSZ~1\AppData\Local\Temp\ccOzFbLV.s:562    .text:000000000000013c lcd_set_xy
C:\Users\KRZYSZ~1\AppData\Local\Temp\ccOzFbLV.s:590    .text:000000000000014c lcd_write_text_xy
C:\Users\KRZYSZ~1\AppData\Local\Temp\ccOzFbLV.s:653    .text:0000000000000172 lcd_write_text_P

UNDEFINED SYMBOLS
__iob
__do_copy_data
